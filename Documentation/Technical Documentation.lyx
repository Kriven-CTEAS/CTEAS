#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "CTEAS: Technical Documentation"
\pdf_author "Zachary A. Jones"
\pdf_subject "CTEAS in-depth mathematical analysis"
\pdf_keywords "CTEAS"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 3
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\bullet 1 0 15 -1
\bullet 2 0 9 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
CTEAS: Technical Documentation
\end_layout

\begin_layout Author
Zachary A.
 Jones
\end_layout

\begin_layout Date
Draft - 11/17/2011
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part
CTEAS - Math Analysis
\end_layout

\begin_layout Standard
A detailed overview of the math used to calculate thermal expansion tensors
 within CTEAS is presented.
 The supporting functions are split into sections containing a list of inputs,
 the actions performed within the function, outputs, and subfunction description
s when applicable.
 Where necessary, descriptions of the math steps have been added for the
 purpose of understanding the sometimes-cryptic syntax of programming languages.
 No descriptions of Matlab or LabVIEW base functions are given.
 It is the hope of the author that the user will have this document and
 the matlab function under scrutiny open side-by-side to gather the required
 understanding of the function.
 Note that the CTERun functions collectively contain 1907 lines of code
 and 616 lines of internal documentation.
 Only the mathematical operations for obtaining thermal expansion matrices
 and data for plotting will be discussed.
\end_layout

\begin_layout Section
Calculating and Plotting a Thermal Expansion Ellipsoid
\end_layout

\begin_layout Standard
The following subsections describe the functions used to calculate the x,
 y, and z coordinates that can be plotted as a three-dimensional ellipsoid
 that represents thermal expansion at a given temperature or range of temperatur
es.
\end_layout

\begin_layout Subsection
getPtTemp.m
\end_layout

\begin_layout Standard
Adjust temperatures using Room Temperature Platinum Lattice Constant obtained
 from JADE files.
 If RT Plat.
 Const.
 doesn't exist, Temperatures get edited manually.
 Set RT Plat.
 Lat.
 Const.
 to 0 in CTEAS GUI.
\end_layout

\begin_layout Subsubsection*
Inputs
\end_layout

\begin_layout Itemize
RefTval = RT Platinum Lattice Constant
\end_layout

\begin_layout Itemize
datin = data read in from JADE files.
\end_layout

\begin_layout Subsubsection*
Actions
\end_layout

\begin_layout Itemize
RefT = 
\begin_inset Formula $20$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
Room Temperature (20
\begin_inset Formula $\textdegree$
\end_inset

C)
\end_layout

\end_deeper
\begin_layout Itemize
PtDaa = 
\begin_inset Formula $\left(\frac{aVal-RefTval}{RefTval}\right)\times100$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
(NOTE: If RefTval=0, PtDaa = aval)
\end_layout

\end_deeper
\begin_layout Itemize
PtDaaErr = 
\begin_inset Formula $\left(\frac{aVal+aErr-RefTval}{RefTval}\right)\times100$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
(NOTE: If RefTval=0, PtDaaErr = 
\begin_inset Formula $aVal+aErr$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
Tcal = 
\begin_inset Formula $\left(3.8274\times PtDaa^{3}\right)-\left(130.5739\times PtDaa^{2}\right)+\left(1101.6564\times PtDaa\right)+RefT$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
(Temperature Correction, no documentation given)
\end_layout

\end_deeper
\begin_layout Itemize
Terr = 
\begin_inset Formula $\left(3.8274\times PtDaaErr^{3}\right)-\left(130.5739\times PtDaaErr^{2}\right)+\left(1101.6564\times PtDaaErr\right)+RefT-Tcal$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
(Error in Temperature Calculation, no documentation given again)
\end_layout

\end_deeper
\begin_layout Paragraph*
Outputs
\end_layout

\begin_layout Itemize
datout = JADE data with corrected Temperature.
\end_layout

\begin_layout Subsection
xtalCTEprep.m
\end_layout

\begin_layout Standard
Prepare data for calculating the 2nd rank Thermal Expansion Tensor per temperatu
re step.
\end_layout

\begin_layout Subsubsection*
Inputs
\end_layout

\begin_layout Itemize
datin = Data from input files with corrected temperatures
\end_layout

\begin_layout Itemize
phasename = Name of phase to be analyzed
\end_layout

\begin_layout Itemize
ordn = Polynomial fit order
\end_layout

\begin_layout Subsubsection*
Actions
\end_layout

\begin_layout Itemize
lsfits = Polynomial fits to the lattice parameters using lpexpand subfunction.
\end_layout

\begin_layout Itemize
entries = List of formatted data from input files containing the phase 
\begin_inset Quotes eld
\end_inset

phasename.
\begin_inset Quotes erd
\end_inset

 Data are sorted using the organizedata1 function within xtalCTEprep.m.
\end_layout

\begin_deeper
\begin_layout Itemize
entries.T = Temperature (
\begin_inset Formula $\textdegree$
\end_inset

C)
\end_layout

\begin_layout Itemize
entries.d = d-spacing in Angstroms
\end_layout

\end_deeper
\begin_layout Itemize
tmp1 = polyfit(entries.T-T_room,log(entries.d),order);
\end_layout

\begin_deeper
\begin_layout Itemize
Polynomial line fit data at a given temperature
\end_layout

\end_deeper
\begin_layout Itemize
params = list of results from the polyfit.
\end_layout

\begin_layout Subsubsection*
Outputs
\end_layout

\begin_layout Itemize
lsfits = polynomial fits of the lattice parameters.
\end_layout

\begin_layout Itemize
entries = Temperature and d-spacing data for the phase to be analyzed.
\end_layout

\begin_layout Itemize
params = list of results from the polyfit.
\end_layout

\begin_layout Subsubsection*
Subfunctions
\end_layout

\begin_layout Subsubsection
organizedata1
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
datin = Data from input files that contains all read data.
\end_layout

\begin_layout Itemize
phasename = Name of phase to be analyzed.
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
Compares each entry in datin with the phasename.
 If it matches, the entry is organized and stored as an entry in datout.
 The temperature and d-spacing data are stored as an entry in entries.
 
\end_layout

\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
datout = Data from input files that corresponds only to the phase that will
 be analyzed (lattice parameters, temperatures, and associated errors)
\end_layout

\begin_layout Itemize
entries = Temperature and d-spacing data that corresponds only to the phase
 that will be analyzed.
\end_layout

\end_deeper
\begin_layout Subsubsection
lpexpand
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
latparams = datout from organizedata1
\end_layout

\begin_layout Itemize
ordn = polynomial fit order
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
T0=
\begin_inset Formula $25$
\end_inset

;
\end_layout

\begin_deeper
\begin_layout Itemize
Room temperature (
\begin_inset Formula $25\textdegree$
\end_inset

C in this file)
\end_layout

\end_deeper
\begin_layout Itemize
fita=polyfit(latparams.T-T0,log(latparams.a),ordn);
\end_layout

\begin_deeper
\begin_layout Itemize
Polynomial fit to each of the lattice parameters (fita, fitb, fitc, etc).
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
fita, fitb, fitc, fitaplha, fitbeta, fitgamma 
\end_layout

\begin_deeper
\begin_layout Itemize
polynomial fits of the lattice parameters (stored in lsfits)
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
xtalCTE.m
\end_layout

\begin_layout Standard
Calculates the thermal expansion tensor at a temperature, T based on the
 polyfits outlined in xtalCTEprep.m.
\end_layout

\begin_layout Subsubsection*
Inputs
\end_layout

\begin_layout Itemize
lsfits = polynomial fits of the lattice parameters.
\end_layout

\begin_layout Itemize
entriesT = Temperature and d-spacing data for the phase to be analyzed.
\end_layout

\begin_layout Itemize
params = list of results from the polyfit in xtalCTEprep.m.
\end_layout

\begin_layout Itemize
T = Temperature
\end_layout

\begin_layout Itemize
system = String containing the system to be analyzed.
\end_layout

\begin_layout Subsubsection*
Actions
\end_layout

\begin_layout Standard
Calculate conversion matrix and recprocal conversion matrix.
 Initialize dtce, dcteErr, xyz1, and xyznrm to finite lengths for memory
 allocation purposes.
 Depricated option for deciding if error weighting should be applied (set
 to 'yes' by default via Ryan's opinion).
 Calculate the thermal expansion for each lattice parameter using getCTETempWErr.
 
\end_layout

\begin_layout Subsubsection*
Outputs
\end_layout

\begin_layout Itemize
ten1 = CTE Tensor at input Temperature.
\end_layout

\begin_layout Itemize
conMat1 = Conversion matrix at input Temperature.
\end_layout

\begin_layout Subsubsection*
Subfunctions
\end_layout

\begin_layout Subsubsection
getconversionmat
\end_layout

\begin_layout Standard
Calculate conversion matrix for use in converting points and vectors from
 the crystal lattice to the orthonormal system.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
fita, fitb, fitc, fitalpha, fitbeta, fitgamma = lsfits
\end_layout

\begin_layout Itemize
T = Temperature (
\begin_inset Formula $\textdegree$
\end_inset

C)
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
aval = getLPTemp(fita, T); 
\end_layout

\begin_deeper
\begin_layout Itemize
Same for all others in lsfits.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $m_{11}=aval\times sin\left(\frac{betaval\times\pi}{180}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $m_{12}=bval\left[\frac{cos\left(\frac{gammaval\times\pi}{180}\right)-cos\left(\frac{betaval\times\pi}{180}\right)\times cos\left(\frac{alphaval\times\pi}{180}\right)}{sin\left(\frac{betaval\times\pi}{180}\right)}\right]$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $m_{22}=bval\left[sin\left(\frac{alphaval\times\pi}{180}\right)^{2}-\frac{m_{12}^{2}}{bval^{2}}\right]^{\frac{1}{2}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $m_{31}=aval\times cos\left(\frac{betaval\times\pi}{180}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $m_{32}=bval\times cos\left(\frac{alphaval\times\pi}{180}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $m_{33}=cval$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $conMatOut=\left[\begin{array}{ccc}
m_{11} & m_{12} & 0\\
0 & m_{22} & 0\\
m_{31} & m_{32} & m_{33}
\end{array}\right]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
conMatOut = calculated conversion matrix at the given input temperature.
\end_layout

\begin_layout Itemize
mcalcsout = 
\begin_inset Formula $m_{**}$
\end_inset

 calculations.
\end_layout

\end_deeper
\begin_layout Subsubsection
getRecipConMatrix
\end_layout

\begin_layout Standard
Calculate the reciprocal conversion matrix.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
fita, fitb, fitc, fitalpha, fitbeta, fitgamma = lsfits
\end_layout

\begin_layout Itemize
T = Temperature (
\begin_inset Formula $\textdegree$
\end_inset

C)
\end_layout

\begin_layout Itemize
mcalcs = 
\begin_inset Formula $m_{**}$
\end_inset

 calculations from getconversionmat.
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
aval = getLPTemp(fita, T); 
\end_layout

\begin_deeper
\begin_layout Itemize
Same for all others in lsfits.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Vol_{1}=aval\times bval\times cval$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Vol_{2}=1-cos\left(\frac{alphaval\times\pi}{180}\right)^{2}-cos\left(\frac{betaval\times\pi}{180}\right)^{2}-cos\left(\frac{gammaval\times\pi}{180}\right)^{2}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Vol_{3}=2\left[cos\left(\frac{alphaval\times\pi}{180}\right)cos\left(\frac{betaval\times\pi}{180}\right)cos\left(\frac{gammaval\times\pi}{180}\right)\right]$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Vol=Vol_{1}\left[Vol_{2}+Vol_{3}\right]^{\frac{1}{2}}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Note: Vol was split into three parts for formatting.
 Only the variable 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $Vol$
\end_inset


\begin_inset Quotes erd
\end_inset

 exists in the code.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $n_{11}=\frac{m_{22}m_{33}}{Vol}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $n_{13}=\frac{-m_{31}m_{22}}{Vol}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $n_{21}=\frac{-m_{12}m_{33}}{Vol}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $n_{22}=\frac{aval\times cval\times sin\left(\frac{betaval\times\pi}{180}\right)}{Vol}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $n_{23}=\frac{m_{31}m_{12}-m_{11}m_{32}}{Vol}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $n_{33}=\frac{m_{11}m_{22}}{Vol}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $matOut=\left[\begin{array}{ccc}
n_{11} & 0 & n_{13}\\
n_{21} & n_{22} & n_{23}\\
0 & 0 & n_{33}
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
matOut = Reciprocal Conversion Matrix at given Temperature.
\end_layout

\end_deeper
\begin_layout Subsubsection
getLPTemp
\end_layout

\begin_layout Standard
Calculate a lattice parameter for a given input temperature based on the
 polyfit of that lattice parameter and room temperature.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
fit1 = Lattice parameter fit (fita, fitb, fitc, etc)
\end_layout

\begin_layout Itemize
T1 = Temperature (
\begin_inset Formula $\textdegree C$
\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
T0 = 
\begin_inset Formula $25$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
Room Temperature (
\begin_inset Formula $\textdegree$
\end_inset

C)
\end_layout

\end_deeper
\begin_layout Itemize
lpoutln = lpoutln+fit1(end-ctr1+1)*((T1-T0).^(ctr1-1));
\end_layout

\begin_deeper
\begin_layout Itemize
In a loop: for ctr1=1:length(fit1)
\end_layout

\end_deeper
\begin_layout Itemize
lpout=exp(lpoutln);
\end_layout

\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
lpout = Calculated lattice parameter based on polyfit.
\end_layout

\end_deeper
\begin_layout Subsubsection
getCTETemp
\end_layout

\begin_layout Standard
Calculate the thermal expansion at a temperature of a lattice direction
 based on the polyfit of the lattice parameter and room temperature.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
fit1 = Lattice parameter fit (fita, fitb, fitc, etc)
\end_layout

\begin_layout Itemize
T1 = Temperature (
\begin_inset Formula $\textdegree C$
\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
alphaout = alphaout+((fit1(end-ctr1)*(ctr1))*((T1-T0)^(ctr1-1)));s
\end_layout

\begin_deeper
\begin_layout Itemize
In a loop: for ctr1=1:length(fit1(1:end-1))
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
alphaout = thermal expansion of a lattice direction at a temperature
\end_layout

\end_deeper
\begin_layout Subsubsection
getCTETempWErr
\end_layout

\begin_layout Standard
Calculate the thermal expansion and its error at a temperature of a lattice
 direction based on the polyfit of the lattice parameter and room temperature.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
fit1 = Lattice parameter fit (fita, fitb, fitc, etc)
\end_layout

\begin_layout Itemize
T1 = Temperature (
\begin_inset Formula $\textdegree C$
\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
alphaout = alphaout+((fit1(end-ctr1)*(ctr1))*((T1-T0)^(ctr1-1)));
\end_layout

\begin_deeper
\begin_layout Itemize
In a loop: for ctr1=1:length(fit1(1:end-1))
\end_layout

\end_deeper
\begin_layout Itemize
[dVal,dErr]=polyval(fit1.p,T1-T0,fit1.S); 
\end_layout

\begin_deeper
\begin_layout Itemize
Obtain the error in measurement
\end_layout

\end_deeper
\begin_layout Itemize
alphaErr=alphaout*dErr/dVal;
\end_layout

\begin_deeper
\begin_layout Itemize
Calculate the error in the thermal expansion.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
alphaout = thermal expansion of a lattice direction at a temperature
\end_layout

\begin_layout Itemize
alphaErr = error in alphaout
\end_layout

\end_deeper
\begin_layout Subsubsection
fitCTETensor
\end_layout

\begin_layout Standard
Build and fit a rank two thermal expansion tensor based on the thermal expansion
s calculated in previous steps.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
xyzin = 
\end_layout

\begin_layout Itemize
dctein = 
\end_layout

\begin_layout Itemize
system = Symmetry to be analyzed.
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
Assign x1, tentemp, and tenout values based on the crystal system analyzed.
\end_layout

\begin_layout Itemize
triclinic:
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)';\\
xyzin(:,2)'.*xyzin(:,2)';\\
xyzin(:,3)'.*xyzin(:,3)';\\
xyzin(:,1)'.*xyzin(:,2)';\\
xyzin(:,1)'.*xyzin(:,3)';\\
xyzin(:,2)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tentemp = x1
\backslash
dctein';
\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & \frac{tentemp(4)}{2} & \frac{tentemp(5)}{2}\\
\frac{tentemp(4)}{2} & tentemp(2) & \frac{tentemp(6)}{2}\\
\frac{tentemp(5)}{2} & \frac{tentemp(6)}{2} & tentemp(3)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
monoclinic:
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)';\\
xyzin(:,2)'.*xyzin(:,2)';\\
xyzin(:,3)'.*xyzin(:,3)';\\
xyzin(:,1)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tentemp = x1
\backslash
dctein';
\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & 0 & \frac{tentemp(4)}{2}\\
0 & tentemp(2) & 0\\
\frac{tentemp(4)}{2} & 0 & tentemp(3)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
tetragonal:
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)'+xyzin(:,2)'.*xyzin(:,2)'\\
xyzin(:,3)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tentemp=inv(x1'*x1)*x1'*dctein';
\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & 0 & 0\\
0 & tentemp(1) & 0\\
0 & 0 & tentemp(2)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
hexagonal:
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)'+xyzin(:,2)'.*xyzin(:,2)'\\
xyzin(:,3)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tentemp=inv(x1'*x1)*x1'*dctein';
\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & 0 & 0\\
0 & tentemp(1) & 0\\
0 & 0 & tentemp(2)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
orthorhombic:
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)';\\
xyzin(:,2)'.*xyzin(:,2)';\\
xyzin(:,3)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tentemp = x1
\backslash
dctein';
\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & 0 & 0\\
0 & tentemp(2) & 0\\
0 & 0 & tentemp(3)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
cubic
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)';\\
xyzin(:,2)'.*xyzin(:,2)';\\
xyzin(:,3)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tentemp=inv(x1'*x1)*x1'*dctein';
\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & 0 & 0\\
0 & tentemp(2) & 0\\
0 & 0 & tentemp(3)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
trigonal:
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)'+xyzin(:,2)'.*xyzin(:,2)'\\
xyzin(:,3)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tentemp=inv(x1'*x1)*x1'*dctein';
\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & 0 & 0\\
0 & tentemp(1) & 0\\
0 & 0 & tentemp(2)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
rhombohedral:
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)'+xyzin(:,2)'.*xyzin(:,2)'\\
xyzin(:,3)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tentemp=inv(x1'*x1)*x1'*dctein';
\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & 0 & 0\\
0 & tentemp(1) & 0\\
0 & 0 & tentemp(2)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
tenout = rank two thermal expansion tensor at input temperature.
\end_layout

\end_deeper
\begin_layout Subsubsection
fitCTETensorWeighted
\end_layout

\begin_layout Standard
Build and fit a weighted rank two thermal expansion tensor based on the
 thermal expansions calculated in previous steps.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
xyzin
\end_layout

\begin_layout Itemize
dctein
\end_layout

\begin_layout Itemize
dcteErr
\end_layout

\begin_layout Itemize
system = Symmetry to be analyzed.
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
W1=diag(1./(dcteErr.*dcteErr));
\end_layout

\begin_deeper
\begin_layout Itemize
Weighting matrix equal to the inverse of the variance for each CTE, with
 the assumption that the error given is the standard deviation of the CTE.
\end_layout

\end_deeper
\begin_layout Itemize
tentemp=inv(x1'*W1*x1)*x1'*W1*dctein';
\end_layout

\begin_layout Itemize
Assign x1 and tenout values based on the crystal system analyzed.
\end_layout

\begin_layout Itemize
triclinic:
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)';\\
xyzin(:,2)'.*xyzin(:,2)';\\
xyzin(:,3)'.*xyzin(:,3)';\\
xyzin(:,1)'.*xyzin(:,2)';\\
xyzin(:,1)'.*xyzin(:,3)';\\
xyzin(:,2)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & \frac{tentemp(4)}{2} & \frac{tentemp(5)}{2}\\
\frac{tentemp(4)}{2} & tentemp(2) & \frac{tentemp(6)}{2}\\
\frac{tentemp(5)}{2} & \frac{tentemp(6)}{2} & tentemp(3)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
monoclinic:
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)';\\
xyzin(:,2)'.*xyzin(:,2)';\\
xyzin(:,3)'.*xyzin(:,3)';\\
xyzin(:,1)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & 0 & \frac{tentemp(4)}{2}\\
0 & tentemp(2) & 0\\
\frac{tentemp(4)}{2} & 0 & tentemp(3)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
tetragonal:
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)'+xyzin(:,2)'.*xyzin(:,2)'\\
xyzin(:,3)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & 0 & 0\\
0 & tentemp(1) & 0\\
0 & 0 & tentemp(2)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
hexagonal:
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)'+xyzin(:,2)'.*xyzin(:,2)'\\
xyzin(:,3)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & 0 & 0\\
0 & tentemp(1) & 0\\
0 & 0 & tentemp(2)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
orthorhombic:
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)';\\
xyzin(:,2)'.*xyzin(:,2)';\\
xyzin(:,3)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & 0 & 0\\
0 & tentemp(2) & 0\\
0 & 0 & tentemp(3)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
cubic
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)';\\
xyzin(:,2)'.*xyzin(:,2)';\\
xyzin(:,3)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & 0 & 0\\
0 & tentemp(2) & 0\\
0 & 0 & tentemp(3)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
trigonal:
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)'+xyzin(:,2)'.*xyzin(:,2)'\\
xyzin(:,3)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & 0 & 0\\
0 & tentemp(1) & 0\\
0 & 0 & tentemp(2)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
rhombohedral:
\end_layout

\begin_deeper
\begin_layout Itemize
x1= 
\begin_inset Formula $\left[\begin{array}{c}
xyzin(:,1)'.*xyzin(:,1)'+xyzin(:,2)'.*xyzin(:,2)'\\
xyzin(:,3)'.*xyzin(:,3)';
\end{array}\right]$
\end_inset


\end_layout

\begin_layout Itemize
tenout = 
\begin_inset Formula $\left[\begin{array}{ccc}
tentemp(1) & 0 & 0\\
0 & tentemp(1) & 0\\
0 & 0 & tentemp(2)
\end{array}\right]$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
tenout = Weighted rank two thermal expansion tensor at input temperature.
\end_layout

\end_deeper
\begin_layout Subsection
plotEllipsoid.m
\end_layout

\begin_layout Standard
Calculate and output x, y, z, and colormap coordinates for plotting a thermal
 expansion ellipsoid using the eigenvectors and eigenvalues of a thermal
 expansion tensor at a temperature.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
V1 - Eigenvectors of the thermal expansion tensor at a temperature
\end_layout

\begin_layout Itemize
e1s = Eigenvalues of the thermal expansion tensor at a temperature
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
e1 = diag(e1s)
\end_layout

\begin_deeper
\begin_layout Itemize
Use only the diagonal components of the eigenvectors
\end_layout

\end_deeper
\begin_layout Itemize
q1=q2=[0:0.02:2]*pi;
\end_layout

\begin_deeper
\begin_layout Itemize
Arrays of points from zero to 
\begin_inset Formula $2\pi$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
[q1,q2]=meshgrid(q1,q2);
\end_layout

\begin_deeper
\begin_layout Itemize
Reassign q1 and q2 to be a series of values that form a sphere in 3-dimensional
 space.
\end_layout

\end_deeper
\begin_layout Itemize
r1=e1(1)*(cos(q1).^2).*(sin(q2).^2)+e1(2)*(sin(q1).^2).*(sin(q2).^2)+e1(3)*(cos(q2).^2)
;
\end_layout

\begin_deeper
\begin_layout Itemize
Determine the radial values for each point in the q1, q2 mesh.
 
\end_layout

\end_deeper
\begin_layout Itemize
x1 = r1.*cos(q1).*sin(q2);
\end_layout

\begin_layout Itemize
y1 = r1.*sin(q1).*sin(q2);
\end_layout

\begin_layout Itemize
z1 = r1.*cos(q2);
\end_layout

\begin_deeper
\begin_layout Itemize
Cartesian coordinates of each point in the q1,q2 mesh.
\end_layout

\end_deeper
\begin_layout Itemize
C1 = eye(3)
\end_layout

\begin_deeper
\begin_layout Itemize
Definition of the original axis.
\end_layout

\end_deeper
\begin_layout Itemize
rot1 = getRotationMat(V1,C1);
\end_layout

\begin_deeper
\begin_layout Itemize
Determine rotation matrix between the Eigenvectors and the C1 axis.
\end_layout

\end_deeper
\begin_layout Itemize
xs=rot1(1,1)*x1+rot1(1,2)*y1+rot1(1,3)*z1; 
\end_layout

\begin_layout Itemize
ys=rot1(2,1)*x1+rot1(2,2)*y1+rot1(2,3)*z1; 
\end_layout

\begin_layout Itemize
zs=rot1(3,1)*x1+rot1(3,2)*y1+rot1(3,3)*z1;
\end_layout

\begin_deeper
\begin_layout Itemize
Using the rotation matrix, define new x, y, and z coordinates to be the
 points on the thermal expansion ellipsoid.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
xs, ys, zs, cs = x, y, and z coordinates of points that construct a thermal
 expansion ellipsoid.
 cs is a colormap.
\end_layout

\end_deeper
\begin_layout Section
Cross-Sections of the Thermal Expansion Ellipsoid
\end_layout

\begin_layout Standard
This section details the functions used in CTEAS that manipulate, determine,
 and plot two-dimensional cross-sections of a thermal expansion ellipsoid.
 The mathematics involved will be a primary focus.
\end_layout

\begin_layout Subsection
EllipseWrap.m
\end_layout

\begin_layout Standard
A wrapper function that contains steps to calculate and plot a cross-section
 of a thermal expansion ellipsoid.
 This is loosely documented because most documentation will occur with the
 given functions.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
TensorSet = Range of CTE Tensors.
\end_layout

\begin_layout Itemize
ConvMatrx = Calculated conversion matrix between crystallographic and cartesian
 coordinates.
\end_layout

\begin_layout Itemize
TempRanges = Range of Temperatures at which the CTE Tensors have been calculated.
\end_layout

\begin_layout Itemize
aval, bval, cval = hkl or UVW to plot perpendicular to.
\end_layout

\begin_layout Itemize
lsfits = Lattice parameter polynomial fits.
\end_layout

\begin_layout Itemize
xscreen, yscreen = Size of figures to be plotted in pixels.
\end_layout

\begin_layout Itemize
inUVW2 = Boolean to determine if using hkl or uvw output.
\end_layout

\begin_layout Itemize
isrhombohedral = Boolean to determine if a symmetry is true rhombohedral
 or analyzed in a hexagonal cell.
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
Create a figure and use plotEllipse.m in a loop throughout the range of temperatu
res in TempRanges.
 Update color maps by an equal division of colors from blue to red for each
 call of plotEllipse.
\end_layout

\begin_layout Itemize
Add arrows for axes if in-plane or eigenvectors else using addarrow4.m.
\end_layout

\begin_layout Itemize
Name arrows with hkl and uvw conventions.
\end_layout

\begin_layout Itemize
Add descriptors to plot (title, x and y labels)
\end_layout

\begin_layout Itemize
Set axis tick labels.
\end_layout

\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
twodvals = List of plotted CTE Ellipse values per temperature.
\end_layout

\end_deeper
\begin_layout Subsection
plotEllipse.m
\end_layout

\begin_layout Standard
From a CTE matrix and an hkl or uvw vector, determines and plots a two-dimension
al cross-section of thermal expansion perpendicular to the input vector.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
M1 = Rank two thermal expansion tensor at a temperature.
\end_layout

\begin_layout Itemize
p1 = hkl or uvw vector to plot perpendicular to.
\end_layout

\begin_layout Itemize
ConMat = Conversion matrix between crystal lattice and orthonormal axis.
\end_layout

\begin_layout Itemize
cmap = Color map for visual temperature differentiation.
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
[t1,t2] = 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\theta$
\end_inset

, respectively.
 Calculated from uvwToAng.m function.
\end_layout

\begin_layout Itemize
[valout,Mf] = Thermal expansion along vector and complete thermal expansion
 matrix, respectively.
 Calculated from getCTEVect.m function.
\end_layout

\begin_layout Itemize
Mplane = Mf(1:2,1:2), the two-dimensional component (located in the plane
 in question) for thermal expansion.
\end_layout

\begin_layout Itemize
[V,D] = Calculated eigenvalues and eigenvectors of Mplane.
\end_layout

\begin_layout Itemize
t3 = [0:0.01:2]*pi, an array containing values from zero to 2
\begin_inset Formula $\pi$
\end_inset

 in 0.01 radian steps.
\end_layout

\begin_layout Itemize
r1 = Array of calculated point distances from the center of the plot based
 on Mplane.
\end_layout

\begin_deeper
\begin_layout Itemize
r1 = (Mplane(1,1)*(cos(t3)).^2)-(2*Mplane(1,2)*cos(t3).*sin(t3))+(Mplane(2,2)*(sin
(t3)).^2);
\end_layout

\end_deeper
\begin_layout Itemize
x1, y1 = x and y components of the r1 vector using the values of t3 as angles.
\end_layout

\begin_deeper
\begin_layout Itemize
x1=r1.*cos(t3); 
\end_layout

\begin_layout Itemize
y1=r1.*sin(t3); 
\end_layout

\end_deeper
\begin_layout Itemize
Plot x1 and y1, tidy up plot with built-in Matlab functions.
\end_layout

\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
V, D, valout, t1, t2, x1, y1 = Described above.
\end_layout

\end_deeper
\begin_layout Subsection
addarrow4.m
\end_layout

\begin_layout Standard
Add an arrow to the thermal expansion ellipsoid cross-section calculated
 by plotEllipse.m if the direction of the arrow lies within the plane.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
M1 = CTE Tensor at temperature.
\end_layout

\begin_layout Itemize
p1 = uvw direction in question.
\end_layout

\begin_layout Itemize
a1 = Reference vector (usually c-axis).
\end_layout

\begin_layout Itemize
axis = Label for axis if applicable.
\end_layout

\begin_layout Itemize
fontsize = Size of fonts (in points) to be displayed for labeling.
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
Convert a1 to orthonormal coordinates using uvwToorth.m.
\end_layout

\begin_deeper
\begin_layout Itemize
a2=uvwToorth(ConMat,a1);
\end_layout

\end_deeper
\begin_layout Itemize
Check to see if the arrow will be in the plane by calculating the cosine
 between the axis in question (converted to orthonormal coordinates) and
 a2.
 If it is equal to zero, the arrow does not lie in the plane.
 Stop function and inplane = 0.
\end_layout

\begin_layout Itemize
If the cosine is not equal to zero, inplane = 1 and the 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\theta$
\end_inset

 angles of the a1 vector are calculated and stored as phi1 and theta1.
\end_layout

\begin_deeper
\begin_layout Itemize
[phi1,theta1] = uvwToAng(a1,ConMat);
\end_layout

\end_deeper
\begin_layout Itemize
The magnitude of the a1 vector can be calculated as the valout portion of
 the getCTEVect.m function.
\end_layout

\begin_deeper
\begin_layout Itemize
[valout,Mf]=getCTEVect(M1,phi1,theta1);
\end_layout

\end_deeper
\begin_layout Itemize
Since a2 is in the direction of a1 but of unit length, it can be multiplied
 by valout to obtain the right length.
\end_layout

\begin_deeper
\begin_layout Itemize
orth1=a2*valout;
\end_layout

\end_deeper
\begin_layout Itemize
The 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\theta$
\end_inset

 angles between the p1 vector and the z-axis must be determined.
\end_layout

\begin_deeper
\begin_layout Itemize
[t1,t2]=uvwToAng(p1,ConMat);
\end_layout

\end_deeper
\begin_layout Itemize
A new conversion matrix, M2 must be determined for creation of a rotation
 matrix.
 Note that the negative values have been added because of the conventions
 Matlab uses.
\end_layout

\begin_deeper
\begin_layout Itemize
m1=rotateVect([-1;0;0],t1,t2);
\end_layout

\begin_layout Itemize
m2=rotateVect([0;1;0],t1,t2);
\end_layout

\begin_layout Itemize
m3=rotateVect([0;0;-1],t1,t2); 
\end_layout

\begin_layout Itemize
M2=[m1';m2';m3']; 
\end_layout

\begin_layout Itemize
r1=getRotationMat(eye(3),M2);
\end_layout

\end_deeper
\begin_layout Itemize
Rotate a2 by multiplying it by r1, then extend it by multiplying it's unit
 length by valout.
\end_layout

\begin_deeper
\begin_layout Itemize
a3=(a2'*r1)'*valout;
\end_layout

\end_deeper
\begin_layout Itemize
a3 is the set of coordinates in orthonormal space that comprises the magnitude
 of thermal expansion in the a1 uvw.
 Plot the components on the 2D cross-section plot.
\end_layout

\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
inplane = 1 if the arrow lies within the plane, 0 if it does not.
 
\end_layout

\end_deeper
\begin_layout Subsection
rotateVect.m
\end_layout

\begin_layout Standard
Rotate a vector by 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\theta$
\end_inset

.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
a1 = An orthonormal vector.
\end_layout

\begin_layout Itemize
T1 = 
\begin_inset Formula $\phi$
\end_inset

 
\end_layout

\begin_layout Itemize
T2 = 
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
Create rotation matrices about Y and Z axes, combine them.
\end_layout

\begin_layout Itemize
t1=T1*pi/180;
\end_layout

\begin_layout Itemize
t2=T2*pi/180;
\end_layout

\begin_layout Itemize
Ry=[cos(t1),0,-sin(t1);0 1 0;sin(t1),0,cos(t1)];
\end_layout

\begin_layout Itemize
Rz=[cos(t2),sin(t2),0;-sin(t2),cos(t2),0;0,0,1];
\end_layout

\begin_layout Itemize
Rfv=Ry*Rz;
\end_layout

\begin_layout Itemize
Rotate about the Z-axis and then the Y-axis, then multiply a1 by the resulting
 rotation matrix.
 
\end_layout

\begin_deeper
\begin_layout Itemize
as1 = (a1'*Rfv)';
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
as1 = Rotated vector.
\end_layout

\end_deeper
\begin_layout Subsection
antirotateVect.m
\end_layout

\begin_layout Standard
Rotate a vector by 
\begin_inset Formula $\theta$
\end_inset

, then 
\begin_inset Formula $\phi$
\end_inset

.
 These angles are usually specified as negative values.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
a1 = An orthonormal vector.
\end_layout

\begin_layout Itemize
T1 = 
\begin_inset Formula $\phi$
\end_inset

 
\end_layout

\begin_layout Itemize
T2 = 
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
Create rotation matrices about Y and Z axes, combine them.
\end_layout

\begin_layout Itemize
t1=T1*pi/180;
\end_layout

\begin_layout Itemize
t2=T2*pi/180;
\end_layout

\begin_layout Itemize
Ry=[cos(t1),0,-sin(t1);0 1 0;sin(t1),0,cos(t1)];
\end_layout

\begin_layout Itemize
Rz=[cos(t2),sin(t2),0;-sin(t2),cos(t2),0;0,0,1];
\end_layout

\begin_layout Itemize
Rfv=Rz*Ry;
\end_layout

\begin_layout Itemize
Rotate about the Y-axis and then the Z-axis, then multiply a1 by the resulting
 rotation matrix.
 
\end_layout

\begin_deeper
\begin_layout Itemize
as1 = (a1'*Rfv)';
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
as1 = Rotated vector.
\end_layout

\end_deeper
\begin_layout Subsection
uvwToAng.m
\end_layout

\begin_layout Standard
Convert a vector composed of h, k, and l components to angles 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\theta$
\end_inset

 in spherical coordinates with negligable length.
 Length is not important because of scaling that takes place in other functions.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
uvw = vector composed of h, k, and l components
\end_layout

\begin_layout Itemize
CM1 = Conversion matrix 
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
Convert uvw to orthornormal coordinates using uvwtoorth(CM1,uvw).
\end_layout

\begin_layout Itemize
Convert orthonormal coordinates to angles using orthToAng(vtmp).
\end_layout

\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
phi, theta = components of unit vector in spherical coordinates
\end_layout

\end_deeper
\begin_layout Subsection
getCTEVect.m
\end_layout

\begin_layout Standard
Calculate the thermal expansion in a direction where 
\begin_inset Formula $\phi$
\end_inset

 is the angle between a vector and the Z-axis and 
\begin_inset Formula $\theta$
\end_inset

 is the angle between the projection of the vector on the X-Y plane and
 the X-axis.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
M1 = CTE Tensor at temperature.
\end_layout

\begin_layout Itemize
phi, theta = components of unit vector in spherical coordinates
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
Ry=[cos(phi1),0,-sin(phi1);0 1 0;sin(phi1),0,cos(phi1)];
\end_layout

\begin_layout Itemize
Rz=[cos(theta1),sin(theta1),0;-sin(theta1),cos(theta1),0;0,0,1];
\end_layout

\begin_layout Itemize
Rfm=Ry*Rz;
\end_layout

\begin_layout Itemize
Mf=Rfm*M1*Rfm';
\end_layout

\begin_layout Itemize
valout=Mf(3,3);
\end_layout

\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
valout = Scaling factor for unit vector.
\end_layout

\begin_layout Itemize
Mf = 2D component of rotated CTE Tensor perpendicular to the vector that
 phi and theta were determined from.
\end_layout

\end_deeper
\begin_layout Subsection
uvwToorth.m
\end_layout

\begin_layout Standard
Convert a vector composed of h, k, and l components to orthonormal x, y,
 and z coordinates.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
CM1 = Conversion matrix at temperature.
\end_layout

\begin_layout Itemize
uvw = uvw in question.
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
v=CM1*uvw/norm(CM1*uvw);
\end_layout

\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
v = Orthonormal vector that is equal to the uvw in length, position, and
 direction in space.
\end_layout

\end_deeper
\begin_layout Subsection
getRotationMat.m
\end_layout

\begin_layout Standard
Determine a rotation matrix for converting between axis systems.
 
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
M1, M2 = Matrices that describe an axis system using vector components.
 eg: [1 0 0; 0 1 0; 0 0 1] for x, y, and z.
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
Get the cosine between each comparative point in both matrices using:
\end_layout

\begin_deeper
\begin_layout Itemize
rotMat=[getCos(M1(:,1),M2(:,1)),getCos(M1(:,2),M2(:,1)),getCos(M1(:,3),M2(:,1));
getCos(M1(:,1),M2(:,2)),getCos(M1(:,2),M2(:,2)),getCos(M1(:,3),M2(:,2));getCos(M
1(:,1),M2(:,3)),getCos(M1(:,2),M2(:,3)),getCos(M1(:,3),M2(:,3))];
\end_layout

\end_deeper
\begin_layout Itemize
function val1=getCos(x1,x2) 
\end_layout

\begin_deeper
\begin_layout Itemize
val1=x1'*x2/(norm(x1)*norm(x2));
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
rotMat = Rotation matrix between axis systems.
\end_layout

\end_deeper
\begin_layout Section
Determination of Thermal Expansion Along a Vector
\end_layout

\begin_layout Subsection
HKLExpansion.m
\end_layout

\begin_layout Standard
Calculate and plot thermal expansion wrt temperature along an hkl or uvw.
 Output expansion values for further manipulation.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
conMat = Calculated conversion matrix between crystallographic and cartesian
 coordinates.
\end_layout

\begin_layout Itemize
Tensors = CTE Tensors at a range of temperatures.
\end_layout

\begin_layout Itemize
hkl = hkl direction in question.
\end_layout

\begin_layout Itemize
Temps = Range of temperatures at which CTE Tensors exist.
\end_layout

\begin_layout Itemize
xscreen, yscreen = Size of figure to be plotted in pixels.
\end_layout

\begin_layout Itemize
lsfits = Polynomial fits to lattice parameters.
\end_layout

\begin_layout Itemize
inUVW3 = Boolean to determine if hkl or uvw should be used for output.
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
Determine thermal expansion in the direction of the given hkl over the range
 of temperatures described by Temps using getCTEVect.m
\end_layout

\begin_layout Itemize
Configure and plot CTE data with labeling.
\end_layout

\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
Exp = Thermal expansion in the direction of the hkl at the range of temperatures
 described by Temps.
\end_layout

\end_deeper
\begin_layout Subsection
orthToAng.m
\end_layout

\begin_layout Standard
Convert orthonormal x, y, and z coordinates to 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\theta$
\end_inset

 angles with unit length, as length will be re-scaled later.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
v1 = Vector described by cartesian coordinates.
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
if abs(v1(1))<.000001 && abs(v1(2))<.000001
\end_layout

\begin_deeper
\begin_layout Itemize
if v1(3)<0 && abs(v1(3))>.000001 
\end_layout

\begin_layout Itemize
phi=180; theta=0; 
\end_layout

\end_deeper
\begin_layout Itemize
elseif v1(3)>0.000001 
\end_layout

\begin_deeper
\begin_layout Itemize
phi=0; 
\end_layout

\begin_layout Itemize
theta=0; 
\end_layout

\end_deeper
\begin_layout Itemize
else 
\end_layout

\begin_deeper
\begin_layout Itemize
error('vector has no length and therefore no direction'); 
\end_layout

\end_deeper
\begin_layout Itemize
end 
\end_layout

\begin_layout Itemize
else 
\end_layout

\begin_deeper
\begin_layout Itemize
theta=atan2(v1(2),v1(1))*180/pi; 
\end_layout

\begin_layout Itemize
phi=acos(v1(3)/norm(v1))*180/pi;
\end_layout

\end_deeper
\begin_layout Itemize
end
\end_layout

\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
phi, theta = Angular components of cartesian vector.
\end_layout

\end_deeper
\begin_layout Section
Miscellaneous Mathematical Operations
\end_layout

\begin_layout Subsection
UVWtoHKL.m
\end_layout

\begin_layout Standard
Convert a vector composed of u, v, and w components to a vector composed
 of h, k, and l components at a given temperature.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
lsfits = Polynomial fits to lattice parameters.
\end_layout

\begin_layout Itemize
UVW = uvw in question.
\end_layout

\begin_layout Itemize
Temp = Temperature to determine hkl relation at.
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
Hden=(U*a^2+V*a*b*cos(gamma)+W*c*a*cos(beta)); 
\end_layout

\begin_layout Itemize
Kden=(U*a*b*cos(gamma)+V*b^2+W*b*c*cos(alpha)); 
\end_layout

\begin_layout Itemize
Lden=(U*c*a*cos(beta)+V*b*c*cos(alpha)+W*c^2);
\end_layout

\begin_layout Itemize
%H/Hden=K/Kden=L/Lden, assume H+K+L==1 to solve for an HKL.
 
\end_layout

\begin_layout Itemize
H=1/(1+(Kden/Hden)+(Lden/Hden)); 
\end_layout

\begin_layout Itemize
K=(H/Hden)*Kden; 
\end_layout

\begin_layout Itemize
L=(H/Hden)*Lden;
\end_layout

\begin_layout Itemize
/rcHKL=[H;K;L];
\end_layout

\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
HKL = hkl calculated from input UVW.
\end_layout

\end_deeper
\begin_layout Subsection
HKLtoUVW.m
\end_layout

\begin_layout Standard
Convert a vector composed of h, k, and l components to a vector composed
 of u, v, and w components at a given temperature.
\end_layout

\begin_layout Itemize
Inputs
\end_layout

\begin_deeper
\begin_layout Itemize
lsfits = Polynomial fits to lattice parameters.
\end_layout

\begin_layout Itemize
HKL = hkl in question.
\end_layout

\begin_layout Itemize
Temp = Temperature to determine UVW relation at.
\end_layout

\end_deeper
\begin_layout Itemize
Actions
\end_layout

\begin_deeper
\begin_layout Itemize
S11=b^2*c^2*sin(degtorad(alpha))^2;
\end_layout

\begin_layout Itemize
S12=a*b*c^2*(cos(degtorad(alpha))*cos(degtorad(beta))-cos(degtorad(gamma)));
\end_layout

\begin_layout Itemize
S13=a*b^2*c*(cos(degtorad(gamma))*cos(degtorad(alpha))-cos(degtorad(beta)));
\end_layout

\begin_layout Itemize
S22=a^2*c^2*sin(degtorad(beta))^2;
\end_layout

\begin_layout Itemize
S23=a^2*b*c*(cos(degtorad(beta))*cos(degtorad(gamma))-cos(degtorad(alpha)));
\end_layout

\begin_layout Itemize
S33=a^2*b^2*sin(degtorad(gamma))^2; 
\end_layout

\begin_layout Itemize
Uden=(HKL(1)*S11+HKL(2)*S12+HKL(3)*S13);
\end_layout

\begin_layout Itemize
Vden=(HKL(1)*S12+HKL(2)*S22+HKL(3)*S23); 
\end_layout

\begin_layout Itemize
Wden=(HKL(1)*S13+HKL(2)*S23+HKL(3)*S33); 
\end_layout

\begin_layout Itemize
%solve by stating that U+V+W==1 
\end_layout

\begin_layout Itemize
U=1/(1+(Vden/Uden)+(Wden/Uden)); 
\end_layout

\begin_layout Itemize
V=(U/Uden)*Vden; 
\end_layout

\begin_layout Itemize
W=(U/Uden)*Wden; 
\end_layout

\begin_layout Itemize
UVW=[U;V;W]; 
\end_layout

\end_deeper
\begin_layout Itemize
Outputs
\end_layout

\begin_deeper
\begin_layout Itemize
UVW = UVW calculated from input HKL.
\end_layout

\end_deeper
\end_body
\end_document
